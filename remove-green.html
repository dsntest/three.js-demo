<!DOCTYPE html>
<html>

<head>
  <title>绿幕扣除</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/110/three.min.js"></script>
  <style>
    body {
      margin: 0;
    }

    canvas {
      width: 100%;
      height: 100%
    }
  </style>
</head>

<body>
  <div id="container"></div>
  <img id="bg" src="test.jpg" style="display:none;">

  <script>
    const videoWidth = 1280;
    const videoHeight = 720;

    const scene = new THREE.Scene();
    const camera = new THREE.OrthographicCamera(-videoWidth / 2, videoWidth / 2, videoHeight / 2, -videoHeight / 2, 0.1, 1000);

    const renderer = new THREE.WebGLRenderer({ alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const chromakeyMaterial = new THREE.ShaderMaterial({
      uniforms: {
        texture: { type: "t", value: null },
        chromaKey: { type: "c", value: new THREE.Color(0x3ca274) },
        range: { type: "f", value: 0.2 }
      },
      vertexShader: `
          varying vec2 vUv;
        
          void main() {
              vUv = uv;
              gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
          }
      `,
      fragmentShader: `
          uniform sampler2D texture;
          uniform vec3 chromaKey;
          uniform float range;
          varying vec2 vUv;
          
          void main() {
              vec3 tColor = texture2D( texture, vUv ).rgb;
              float a = (length(tColor - chromaKey) - range) / (range);
              a = clamp(a, 0.0, 1.0);
              gl_FragColor = vec4(tColor, a);
          }
      `,
      transparent: true,
      side: THREE.DoubleSide
    });


    const videoElement = document.createElement('video');
    if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
      navigator.mediaDevices
        .getUserMedia({ video: true, audio: true })
        .then(function (stream) {
          videoElement.srcObject = stream;
          videoElement.play();
        });
    }

    const videoTexture = new THREE.VideoTexture(videoElement);
    chromakeyMaterial.uniforms.texture.value = videoTexture;

    const planeGeometry = new THREE.PlaneGeometry(videoWidth, videoHeight);
    const plane = new THREE.Mesh(planeGeometry, chromakeyMaterial);
    scene.add(plane);


    const bgTexture = new THREE.TextureLoader().load("test.jpg"); // 背景图片路径
    bgTexture.minFilter = THREE.LinearFilter;
    const bgMaterial = new THREE.MeshBasicMaterial({ map: bgTexture });

    const bgPlane = new THREE.Mesh(planeGeometry, bgMaterial);
    bgPlane.position.z = -1;
    scene.add(bgPlane);

    camera.position.z = 1;

    function animate() {
      requestAnimationFrame(animate);
      if (videoElement.readyState === videoElement.HAVE_ENOUGH_DATA) {
        videoTexture.needsUpdate = true;
        // 更新背景图像的纹理
        bgTexture.needsUpdate = true;
      }
      renderer.render(scene, camera);
    }

    animate();
  </script>
</body>

</html>